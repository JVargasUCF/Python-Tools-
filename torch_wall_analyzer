# torch_wall_analyzer.py
# GUI + solver that:
# 1) Loads wall profile CSV: columns x, r_inner, r_outer  (axisymmetric)
# 2) Predicts temperature field (no measured points needed) using:
#    - Cantera HP equilibrium for H2/O2 to get Tad (gas driving temp)
#    - Gas-side h(x): user constant, Dittus–Boelter (pipe-like), or impingement-boosted
#    - GH2 coolant h_c(x) via Dittus–Boelter + energy balance marching for T_c(x)
#    - Cylindrical conduction network per x => q'(x), q''_inner/outer, T_wi(x), T_wo(x)
#    - Optional fine radial profile at each x to generate (x, r, T) "temperature points" for plotting
# 3) Plots: (x–r) temperature map, T_wall vs x, q'' vs x, T_coolant vs x
#
# Use:
#   python torch_wall_analyzer.py
#
# CSV outputs (via "Save Results"):
#   - generated_temperature_points.csv : (x_m, r_m, T_K) from radial profiles
#   - axial_results.csv : x, T_wi, T_wo, qpp_inner, qpp_outer, T_coolant, h_g, h_c
#
# Notes:
# - This is a first-order engineering model (no CFD); tune HTCs and hotspot boost as needed.
# - Ensure Cantera finds 'h2o2.yaml' (installed with Cantera 3.x typically).

import math
import numpy as np
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from dataclasses import dataclass
from typing import Callable, Optional, Tuple

# ----------------------------- Core Data Structures -----------------------------

@dataclass
class MatSolid:
    rho: float
    cp: float
    k_const: Optional[float] = None
    k_of_T: Optional[Callable[[float], float]] = None
    def k(self, T):
        if self.k_of_T: return float(self.k_of_T(T))
        return float(self.k_const if self.k_const is not None else 16.0)

@dataclass
class GasSideHT:
    model: str = "user"        # 'user' | 'pipe_D_B' | 'impinging_boost'
    h_user: float = 2000.0     # W/m^2-K if model='user'
    Dh: float = 3.0e-3         # m, cavity hydraulic diameter (if using pipe model)
    A_flow: float = 1.0e-5     # m^2, effective cavity area
    boost_factor: float = 3.0  # multiplier near hotspot
    hotspot_x: Optional[float] = None
    hotspot_span: float = 0.01 # m (Gaussian width)

@dataclass
class GH2Coolant:
    mdot: float         # kg/s
    T_in: float         # K
    rho: float          # kg/m^3
    mu: float           # Pa·s
    k_gas: float        # W/m-K
    cp: float           # J/kg-K
    Dh: float           # m
    A_flow: float       # m^2
    perimeter: float    # m wetted perimeter vs wall (inner surface)
    heating: bool = True

@dataclass
class WallProfile:
    x: np.ndarray
    r_inner: np.ndarray
    r_outer: np.ndarray

# ----------------------------- Helpers: Heat Transfer & Cantera -----------------------------

def dittus_boelter(mdot, rho, mu, k, Dh, A_flow, Pr=0.7, heating=True):
    U = mdot / (rho * max(A_flow, 1e-12))
    Re = rho * U * Dh / max(mu, 1e-12)
    n = 0.4 if heating else 0.3
    Nu = 0.023 * (max(Re,1.0)**0.8) * (max(Pr,1e-4)**n)
    h = Nu * k / max(Dh, 1e-12)
    return h, Re, Nu, U

def cantera_mix_props_H2O2(mdot_H2, mdot_O2, T0=300.0, P_kPa=1000.0, mech='h2o2.yaml'):
    import cantera as ct
    gas = ct.Solution(mech)
    MW = gas.molecular_weights/1000.0
    nH2 = mdot_H2/(MW[gas.species_index('H2')]+1e-30)
    nO2 = mdot_O2/(MW[gas.species_index('O2')]+1e-30)
    gas.TPX = T0, P_kPa*1000.0, {'H2':nH2, 'O2':nO2}
    gas.equilibrate('HP')  # Tad
    Tad = gas.T
    cp, cv = gas.cp_mass, gas.cv_mass
    gamma = cp/max(cv,1e-9)
    Rmass = cp-cv
    mu = gas.viscosity
    k  = gas.thermal_conductivity
    Pr = mu*cp/max(k,1e-12)
    return {'gas':gas, 'Tad':Tad, 'cp':cp, 'gamma':gamma, 'R':Rmass, 'mu':mu, 'k':k, 'Pr':Pr}

def gas_side_h_along_x(x, cfg: GasSideHT, mdot_gas, rho_g, mu_g, k_g, cp_g=2000.0):
    if cfg.model == 'user':
        h = np.full_like(x, cfg.h_user, dtype=float)
    else:
        # Dittus–Boelter base
        U = mdot_gas/(rho_g*max(cfg.A_flow,1e-12))
        Re = rho_g*U*cfg.Dh/max(mu_g,1e-12)
        Pr = mu_g*cp_g/max(k_g,1e-12)
        Nu = 0.023*(max(Re,1.0)**0.8)*(max(Pr,1e-4)**0.4)
        h_base = Nu*k_g/max(cfg.Dh,1e-12)
        h = np.full_like(x, h_base, dtype=float)

    if cfg.model == 'impinging_boost' and cfg.hotspot_x is not None:
        w = cfg.hotspot_span
        boost = 1.0 + (cfg.boost_factor-1.0)*np.exp(-((x-cfg.hotspot_x)/w)**2)
        h *= boost
    return h

# cylindrical per-length thermal network: q' and wall temperatures
def cyl_network_steady(r_i, r_o, h_g, T_g, h_c, T_c, k):
    Rg = 1.0 / (max(h_g,1e-9) * 2*math.pi*max(r_i,1e-9))
    Rw = math.log(max(r_o,1e-9)/max(r_i,1e-9)) / (2*math.pi*max(k,1e-9))
    Rc = 1.0 / (max(h_c,1e-9) * 2*math.pi*max(r_o,1e-9))
    qpl = (T_g - T_c) / (Rg + Rw + Rc)  # W/m
    T_wi = T_g - qpl*Rg
    T_wo = T_c + qpl*Rc
    return qpl, T_wi, T_wo

# fine radial profile in the solid (handles k(T) by iteration)
def radial_profile_cylindrical(T_wi, T_wo, r_i, r_o, kfun, Nr=40, iters=10):
    r = np.linspace(r_i, r_o, Nr)
    T = np.linspace(T_wi, T_wo, Nr)
    for _ in range(iters):
        k = np.array([kfun(Tj) for Tj in T])
        A = np.zeros((Nr,Nr)); b = np.zeros(Nr)
        # Dirichlet BCs
        A[0,0]=1.0; b[0]=T_wi
        A[-1,-1]=1.0; b[-1]=T_wo
        # interior
        for j in range(1,Nr-1):
            rjm = 0.5*(r[j]+r[j-1]); rjp = 0.5*(r[j]+r[j+1])
            km = 0.5*(k[j]+k[j-1]);  kp = 0.5*(k[j]+k[j+1])
            Aw = km*rjm/(r[j]-r[j-1])
            Ae = kp*rjp/(r[j+1]-r[j])
            A[j,j-1] = -Aw
            A[j,j]   = Aw + Ae
            A[j,j+1] = -Ae
            b[j]     = 0.0
        T = np.linalg.solve(A,b)
    return r, T

# full conjugate march along x
def solve_conjugate_along_x(
    x, r_inner, r_outer,
    mdot_H2, mdot_O2,
    Pd_kPa,
    mat: MatSolid,
    gas_ht: GasSideHT,
    gh2: GH2Coolant,
    mech='h2o2.yaml',
    T_reactants_K=300.0,
    iters=3
):
    # 1) gas mixture / properties (Tad etc)
    eq = cantera_mix_props_H2O2(mdot_H2, mdot_O2, T_reactants_K, max(2*Pd_kPa,1000.0), mech)
    Tgas = eq['Tad']
    rho_gas = (Pd_kPa*1000.0)/(eq['R']*max(Tgas,1.0))
    mdot_gas = mdot_H2 + mdot_O2

    # 2) gas-side h(x)
    h_g = gas_side_h_along_x(x, gas_ht, mdot_gas, rho_gas, eq['mu'], eq['k'], cp_g=eq['cp'])

    # 3) iterate coolant marching + wall network
    T_c = np.zeros_like(x); T_c[0] = gh2.T_in
    h_c = np.zeros_like(x)
    qpl = np.zeros_like(x)
    T_wi = np.zeros_like(x); T_wo = np.zeros_like(x)

    for _ in range(iters):
        # update coolant HTC (can be made T-dependent)
        for i in range(len(x)):
            hci, *_ = dittus_boelter(gh2.mdot, gh2.rho, gh2.mu, gh2.k_gas, gh2.Dh, gh2.A_flow, Pr=0.7, heating=gh2.heating)
            h_c[i] = hci
        # solve network at each slice
        for i in range(len(x)):
            k_loc = mat.k(0.5*(Tgas + T_c[i]))
            qpl[i], T_wi[i], T_wo[i] = cyl_network_steady(r_inner[i], r_outer[i], h_g[i], Tgas, h_c[i], T_c[i], k_loc)
        # march coolant
        for i in range(len(x)-1):
            dx = x[i+1]-x[i]
            T_c[i+1] = T_c[i] + qpl[i]*dx / max(gh2.mdot*gh2.cp, 1e-12)

    qpp_inner = qpl / (2*math.pi*np.maximum(r_inner,1e-9))
    qpp_outer = qpl / (2*math.pi*np.maximum(r_outer,1e-9))
    return {
        'T_gas'      : Tgas,
        'h_g'        : h_g,
        'T_coolant'  : T_c,
        'h_c'        : h_c,
        'q_per_len'  : qpl,
        'qpp_inner'  : qpp_inner,
        'qpp_outer'  : qpp_outer,
        'T_wall_inner': T_wi,
        'T_wall_outer': T_wo
    }

# ----------------------------- Plotting -----------------------------

def idw_interpolate(xq, rq, pts, p=2.0, eps=1e-12):
    x = pts[:, 0][:, None]
    r = pts[:, 1][:, None]
    T = pts[:, 2][:, None]
    Xq = xq.ravel()[None, :]
    Rq = rq.ravel()[None, :]
    d2 = (x - Xq)**2 + (r - Rq)**2 + eps
    w = 1.0 / (d2**(p/2.0))
    Tq = (w * T).sum(axis=0) / w.sum(axis=0)
    return Tq.reshape(xq.shape)

def plot_temperature_field_from_points(pts, wall: WallProfile, nx=240, nr=120, title='Temperature Field (predicted)'):
    x_min, x_max = wall.x.min(), wall.x.max()
    r_max = wall.r_outer.max()
    Xg, Rg = np.meshgrid(np.linspace(x_min, x_max, nx), np.linspace(0.0, r_max, nr))
    Tg = idw_interpolate(Xg, Rg, pts, p=2.0)
    # mask outside solid
    r_outer_interp = np.interp(Xg[0, :], wall.x, wall.r_outer)
    mask = Rg > r_outer_interp[None, :]
    Tg_masked = np.ma.array(Tg, mask=mask)
    plt.figure(figsize=(9, 3.6))
    cf = plt.pcolormesh(Xg, Rg, Tg_masked, shading='auto')
    plt.colorbar(cf, label='Temperature [K]')
    plt.plot(wall.x, wall.r_outer, 'k-', lw=1.2)
    plt.plot(wall.x, wall.r_inner, 'k--', lw=1.0)
    plt.xlabel('Axial position x [m]'); plt.ylabel('Radius r [m]')
    plt.title(title)
    plt.tight_layout()

def plot_line(x, y, ylabel, title):
    plt.figure(figsize=(8.5, 2.6))
    plt.plot(x, y)
    plt.xlabel('x [m]'); plt.ylabel(ylabel); plt.title(title); plt.tight_layout()

# ----------------------------- GUI -----------------------------

def run_gui():
    root = tk.Tk()
    root.title("Torch Wall Thermal (No CFD) — Model & Plot")

    # --- file pickers ---
    def browse_profile():
        p = filedialog.askopenfilename(title="Select WALL PROFILE CSV (x, r_inner, r_outer)",
                                       filetypes=[("CSV files","*.csv"), ("All files","*.*")])
        if p: prof_path.set(p)

    # --- run analysis ---
    def run_now():
        try:
            # wall profile
            if not prof_path.get().strip():
                messagebox.showerror("Missing file", "Please select a wall profile CSV.")
                return
            dfw = pd.read_csv(prof_path.get().strip())
            for col in ("x","r_inner","r_outer"):
                if col not in dfw.columns:
                    messagebox.showerror("Bad CSV", "Profile CSV must include columns: x, r_inner, r_outer.")
                    return
            x = dfw["x"].to_numpy()
            r_inner = dfw["r_inner"].to_numpy()
            r_outer = dfw["r_outer"].to_numpy()
            order = np.argsort(x); x=x[order]; r_inner=r_inner[order]; r_outer=r_outer[order]
            wall = WallProfile(x=x, r_inner=r_inner, r_outer=r_outer)

            # materials & configs
            mat = MatSolid(
                rho=float(ent_mat_rho.get()),
                cp=float(ent_mat_cp.get()),
                k_const=float(ent_mat_k.get())
            )

            gastype = gas_model.get()
            gas_ht = GasSideHT(
                model=gastype,
                h_user=float(ent_huser.get()),
                Dh=float(ent_Dh_gas.get()),
                A_flow=float(ent_Agas.get()),
                boost_factor=float(ent_boost.get()),
                hotspot_x=float(ent_hotx.get()) if gastype=="impinging_boost" else None,
                hotspot_span=float(ent_hotw.get())
            )

            gh2 = GH2Coolant(
                mdot=float(ent_mdot.get()),
                T_in=float(ent_Tin.get()),
                rho=float(ent_rho.get()),
                mu=float(ent_mu.get()),
                k_gas=float(ent_kg.get()),
                cp=float(ent_cp.get()),
                Dh=float(ent_Dh.get()),
                A_flow=float(ent_A.get()),
                perimeter=2.0*math.pi*np.mean(r_inner),  # inner perimeter (simple)
                heating=True
            )

            # flows & conditions
            mdot_H2 = float(ent_mdotH2.get())
            mdot_O2 = float(ent_mdotO2.get())
            Pd_kPa  = float(ent_Pd.get())
            mech    = mech_var.get()
            iters   = int(ent_iters.get())

            # solve conjugate along x
            res = solve_conjugate_along_x(
                x, r_inner, r_outer,
                mdot_H2, mdot_O2,
                Pd_kPa,
                mat, gas_ht, gh2,
                mech=mech,
                T_reactants_K=float(ent_Tinlet.get()),
                iters=iters
            )

            # build synthetic temperature points from radial profiles at each x
            Nr = int(ent_Nr.get())
            pts = []
            for i in range(len(x)):
                rgrid, Tgrid = radial_profile_cylindrical(
                    res['T_wall_inner'][i], res['T_wall_outer'][i],
                    r_inner[i], r_outer[i], mat.k, Nr=Nr
                )
                for rj, Tj in zip(rgrid, Tgrid):
                    pts.append((x[i], rj, Tj))
            pts_arr = np.array(pts)

            # plots
            if var_plot_field.get():  plot_temperature_field_from_points(pts_arr, wall, nx=int(ent_nx.get()), nr=int(ent_nr.get()))
            if var_plot_Ti.get():     plot_line(x, res['T_wall_inner'], "T_wall, inner [K]", "Inner Wall Temperature")
            if var_plot_To.get():     plot_line(x, res['T_wall_outer'], "T_wall, outer [K]", "Outer Wall Temperature")
            if var_plot_q.get():      plot_line(x, res['qpp_inner'], "q''_inner [W/m²]", "Heat Flux (inner)")
            if var_plot_qo.get():     plot_line(x, res['qpp_outer'], "q''_outer [W/m²]", "Heat Flux (outer)")
            if var_plot_Tc.get():     plot_line(x, res['T_coolant'], "T_coolant [K]", "Coolant Bulk Temperature")
            if var_plot_hg.get():     plot_line(x, res['h_g'], "h_g [W/m²-K]", "Gas-side HTC")
            if var_plot_hc.get():     plot_line(x, res['h_c'], "h_c [W/m²-K]", "Coolant-side HTC")
            plt.show()

            # stash results for "Save Results"
            run_now.last_pts = pts_arr
            run_now.last_axial = pd.DataFrame({
                'x_m': x,
                'T_wall_inner_K': res['T_wall_inner'],
                'T_wall_outer_K': res['T_wall_outer'],
                "qpp_inner_Wpm2": res['qpp_inner'],
                "qpp_outer_Wpm2": res['qpp_outer'],
                "T_coolant_K": res['T_coolant'],
                "h_g_Wpm2K": res['h_g'],
                "h_c_Wpm2K": res['h_c']
            })
            messagebox.showinfo("Done", "Analysis complete. Use 'Save Results' to export CSVs if desired.")

        except Exception as e:
            messagebox.showerror("Error", f"{type(e).__name__}: {e}")

    def save_results():
        try:
            pts = getattr(run_now, "last_pts", None)
            axial = getattr(run_now, "last_axial", None)
            if pts is None or axial is None:
                messagebox.showwarning("Nothing to save", "Run Analysis first.")
                return
            p_dir = filedialog.askdirectory(title="Choose folder to save CSVs")
            if not p_dir: return
            pd.DataFrame(pts, columns=['x_m','r_m','T_K']).to_csv(f"{p_dir}/generated_temperature_points.csv", index=False)
            axial.to_csv(f"{p_dir}/axial_results.csv", index=False)
            messagebox.showinfo("Saved", f"Saved:\n- {p_dir}/generated_temperature_points.csv\n- {p_dir}/axial_results.csv")
        except Exception as e:
            messagebox.showerror("Save error", f"{type(e).__name__}: {e}")

    # ------------------- UI Layout -------------------
    frm = ttk.Frame(root, padding=10); frm.grid(row=0, column=0, sticky="nsew")
    root.columnconfigure(0, weight=1); root.rowconfigure(0, weight=1)

    prof_path = tk.StringVar()
    ttk.Label(frm, text="Wall profile CSV (x, r_inner, r_outer):").grid(row=0, column=0, sticky="w")
    ttk.Entry(frm, textvariable=prof_path, width=54).grid(row=1, column=0, sticky="we")
    ttk.Button(frm, text="Browse…", command=browse_profile).grid(row=1, column=1, padx=6)

    # Materials
    ttk.Label(frm, text="Material (solid): ρ [kg/m³], cp [J/kg-K], k [W/m-K]").grid(row=2, column=0, sticky="w", pady=(8,0))
    ent_mat_rho = ttk.Entry(frm, width=10); ent_mat_cp = ttk.Entry(frm, width=10); ent_mat_k = ttk.Entry(frm, width=10)
    ent_mat_rho.insert(0,"8000"); ent_mat_cp.insert(0,"500"); ent_mat_k.insert(0,"16")
    ent_mat_rho.grid(row=3, column=0, sticky="w"); ent_mat_cp.place(x=210,y=76); ent_mat_k.place(x=320,y=76)

    # Gas-side HTC
    ttk.Label(frm, text="Gas-side HTC model:").grid(row=4, column=0, sticky="w", pady=(8,0))
    gas_model = tk.StringVar(value="impinging_boost")
    ttk.Radiobutton(frm, text="User constant", variable=gas_model, value="user").grid(row=5, column=0, sticky="w")
    ttk.Radiobutton(frm, text="Pipe (Dittus–Boelter)", variable=gas_model, value="pipe_D_B").grid(row=5, column=1, sticky="w")
    ttk.Radiobutton(frm, text="Impingement boost", variable=gas_model, value="impinging_boost").grid(row=5, column=2, sticky="w")

    # Gas-side params
    grid_g = ttk.Frame(frm); grid_g.grid(row=6, column=0, columnspan=3, sticky="we")
    def L(r,c,t): ttk.Label(grid_g, text=t).grid(row=r, column=c, sticky="w")
    def E(r,c,v,w=8):
        e=ttk.Entry(grid_g,width=w); e.insert(0,v); e.grid(row=r,column=c,sticky="w"); return e
    L(0,0,"h_user"); ent_huser=E(0,1,"2000")
    L(0,2,"Dh_gas [m]"); ent_Dh_gas=E(0,3,"0.003")
    L(0,4,"A_gas [m²]"); ent_Agas=E(0,5,"1.2e-5")
    L(1,0,"boost ×"); ent_boost=E(1,1,"3.0")
    L(1,2,"hotspot x [m]"); ent_hotx=E(1,3,"0.02")
    L(1,4,"hotspot span [m]"); ent_hotw=E(1,5,"0.006")

    # Coolant GH2
    ttk.Label(frm, text="GH₂ coolant: ṁ, T_in, ρ, μ, k_g, cp, D_h, A_flow").grid(row=7, column=0, sticky="w", pady=(8,0))
    grid_c = ttk.Frame(frm); grid_c.grid(row=8, column=0, columnspan=3, sticky="we")
    ent_mdot=E:=lambda r,c,v: None
    # compact entries
    e = []
    for val in ("0.008","110","8.0","9e-6","0.2","13500","1.5e-3","1.77e-6"):
        e.append(ttk.Entry(grid_c, width=10)); e[-1].insert(0,val)
    labels = ["ṁ[kg/s]","T_in[K]","ρ","μ[Pa·s]","k_g[W/m-K]","cp[J/kg-K]","D_h[m]","A_flow[m²]"]
    for j,(lab,ej) in enumerate(zip(labels,e)):
        ttk.Label(grid_c, text=lab).grid(row=0, column=2*j, sticky="w"); ej.grid(row=0, column=2*j+1, sticky="w")
    ent_mdot,ent_Tin,ent_rho,ent_mu,ent_kg,ent_cp,ent_Dh,ent_A = e

    # Flows & conditions
    ttk.Label(frm, text="Torch flows & boundary: mdot_H2, mdot_O2 [kg/s], Pd [kPa], T_react[K], Cantera mech, iterations").grid(row=9, column=0, sticky="w", pady=(8,0))
    grid_f = ttk.Frame(frm); grid_f.grid(row=10, column=0, columnspan=3, sticky="we")
    ent_mdotH2 = ttk.Entry(grid_f, width=10); ent_mdotH2.insert(0,"0.002")
    ent_mdotO2 = ttk.Entry(grid_f, width=10); ent_mdotO2.insert(0,"0.016")
    ent_Pd     = ttk.Entry(grid_f, width=10); ent_Pd.insert(0,"500")
    ent_Tinlet = ttk.Entry(grid_f, width=10); ent_Tinlet.insert(0,"300")
    mech_var   = tk.StringVar(value="h2o2.yaml")
    ent_mech   = ttk.Entry(grid_f, width=12, textvariable=mech_var)
    ent_iters  = ttk.Entry(grid_f, width=6); ent_iters.insert(0,"3")
    for j,(lab,ej) in enumerate([
        ("mdot_H2", ent_mdotH2), ("mdot_O2", ent_mdotO2),
        ("Pd [kPa]", ent_Pd), ("T_react [K]", ent_Tinlet),
        ("Mechanism", ent_mech), ("iters", ent_iters)
    ]):
        ttk.Label(grid_f, text=lab).grid(row=0, column=2*j, sticky="w"); ej.grid(row=0, column=2*j+1, sticky="w")

    # Field/Profiles settings
    ttk.Label(frm, text="Generated radial profile points per x (Nr), field grid nx×nr:").grid(row=11, column=0, sticky="w", pady=(8,0))
    ent_Nr = ttk.Entry(frm, width=8); ent_Nr.insert(0,"60"); ent_Nr.grid(row=11, column=0, sticky="w", padx=(350,0))
    ent_nx = ttk.Entry(frm, width=8); ent_nx.insert(0,"240"); ent_nx.place(x=530, y=355)
    ent_nr = ttk.Entry(frm, width=8); ent_nr.insert(0,"120"); ent_nr.place(x=590, y=355)

    # Plot toggles
    var_plot_field = tk.IntVar(value=1)
    var_plot_Ti = tk.IntVar(value=1)
    var_plot_To = tk.IntVar(value=1)
    var_plot_q  = tk.IntVar(value=1)
    var_plot_qo = tk.IntVar(value=0)
    var_plot_Tc = tk.IntVar(value=1)
    var_plot_hg = tk.IntVar(value=0)
    var_plot_hc = tk.IntVar(value=0)
    ttk.Label(frm, text="Plots:").grid(row=12, column=0, sticky="w", pady=(8,0))
    ttk.Checkbutton(frm, text="Field x–r", variable=var_plot_field).grid(row=13, column=0, sticky="w")
    ttk.Checkbutton(frm, text="T_wall inner", variable=var_plot_Ti).grid(row=13, column=1, sticky="w")
    ttk.Checkbutton(frm, text="T_wall outer", variable=var_plot_To).grid(row=13, column=2, sticky="w")
    ttk.Checkbutton(frm, text="q'' inner", variable=var_plot_q).grid(row=14, column=0, sticky="w")
    ttk.Checkbutton(frm, text="q'' outer", variable=var_plot_qo).grid(row=14, column=1, sticky="w")
    ttk.Checkbutton(frm, text="T_coolant", variable=var_plot_Tc).grid(row=14, column=2, sticky="w")
    ttk.Checkbutton(frm, text="h_g", variable=var_plot_hg).grid(row=15, column=0, sticky="w")
    ttk.Checkbutton(frm, text="h_c", variable=var_plot_hc).grid(row=15, column=1, sticky="w")

    # Buttons
    ttk.Button(frm, text="Run Analysis", command=run_now).grid(row=16, column=0, pady=10, sticky="w")
    ttk.Button(frm, text="Save Results", command=save_results).grid(row=16, column=1, pady=10, sticky="w")

    root.mainloop()

# --------- main ---------
if __name__ == "__main__":
    run_gui()
